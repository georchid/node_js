   Как работает NODE.JS 
   V8 - движок отвечает за выполнение кода
   Встроенные модули Node.js (path, os, fs, http и тд) - API для взаимодействия с системой
   C++ Bindings - посредники обеспечивающие взаимодействие встроенных модулей с LibUV
   LibUV - Библиотека, написанная на c++ обеспечивает поддержку необлокирующих операций ввода-вывода
   Внешние модули Node.js (express, mocha и тд)

   Потоки и процессы
   Node.js не позволяет создавать много потоков
   в рамках одного процесса ноде работает только один поток (привет питон и прочие интерпретируемые ЯП=))
   -> нам нужно больше асинхронщины=)))

   Libuv состоит из цикла событий и пула потоков
   event loop отвечает за работу с колбэками асинхронных опираций
   thread pool работает с синхронными операциями
   стоит уточникть, что асинхронщина работает в браузере по другому
   WEB API

   Even Loop - бесконечный цикл, в котором вызываются колбэк функции,
   связанные с событиями. С одним событием можно ассоциировать несколько колбэков
   Выполнение в цикле событий означает выполнение в основном потоке Node.js
   Поэтому эти колбэк функции следует проектировать таким образом,
   что бы они работали не очень долго

   Thread pool - для асинхронного выполнения блокирующих операций. Т.е
   Операцию можно назначить на один из потока пула Node.js. По умолчанию в пуле 4 потока (можно увеличить до 1024)
   С помощью Thread Pool выполняются I/O операции, и задачи, нагружающие процессор

   Libuv старается делегировать задачи средствам ОС, если это невозможно, задача помещается в пул потоков.

   После завершения операции событие попадает в EventQueue, после этого событие возьмется и обработается в рамках
   текущей итерации цикла событий (у событий есть разные приоритеты в очереди дада, как и в ОС)

   как работает Event Loop

   пока цикл событий работает:
        пока есть события для обработки:
            e = получить следующее событие
            если для события есть колбэк функция:
                вызвать колбэк функцию
    
    Примеры событий:
        - Данные были записаны в файл
        - получена следующая часть данных от удаленного сервера
    
    В цикле событий есть несколько очередей событий (тк разные события имеют разные приоритеты)
    1. Timers (setTimeout, setInterval) колбэки для истекших таймеров
    2. Pending I/O колбэки, отложенные до следующей итерации
    3. Idle, Prepare используются внутри Node.js
    4. Poll Получить и выполнить колбэки I/O
    5. Check колбэки setImmediate
    6. Close close event callback
    7. Далее выход или новая итерация EventLoop

    помимо этих событий есть событие process.nextTick, позволяющее вызвать колбэк практически немедленно. Тк после каждого этапа
    выполняется проверка события nextTick. Кроме этого есть промисы. Разные колбэки можно ассоциировать с разными состояниями промиса.
    Такие колбэки так же выполняются немедленно.
    Резюмируя. Nexttick имеет приоритет перед другими событиями и обрабатывается на текущей итерации

    SetImmediate вызывает колбэк функция на текущей или следующей итерации цикла событий


    --------------------

    Блокирование цикла событий
    может возникнуть ситуация, при которой определенная колбэк функция выполняется долго. Тогда другие события будут ожидать в очереди
    Код, который я пишу не должен занимать цикл событий слишком долго. если что используй пул потоков LibUv


// Пример SETIMMEDIATE
setImmediate(() => {
    console.log('immediate cb')
});

// Практическая секция по циклу событий

